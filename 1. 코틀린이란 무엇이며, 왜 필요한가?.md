# 1. 코틀린 맛보기

```
// age 프로퍼티의 디폴트 값은 null
data class Person(val name: String, val age: Int? = null)

fun main(args: Array<String>) {
    val persons = listOf(
        Person("영희"), Person("철수", age = 20)
    )

    // maxBy 함수에 전달한 람다 식은 파라미터를 하나씩 받음 
    val oldest = persons.maxBy { it.age ?: 0 }
    print("나이가 가장 많은 사람: $oldest")
}
```

# 2. 코틀린 주요 특성

## 1. 대상 플랫폼: 서버, 안드로이드 등 자바가 실행되는 모든 곳

- 자바가 사용되고 있는 모든 용도에 적합
- 간결하고 생산적이며 안전한 자바 대체 언어

## 2. 정적 타입 지정 언어

- 정적 타입 지정 언어
    - 컴파일 시점에 구성 요소 타입을 알 수 있음
- 동적 타입 지정 언어
    - 타입과 관계없이 모든 값을 변수에 넣을 수 있음
- 모든 변수의 타입을 컴파일러가 문맥으로 자동 유추
- 널이 될 수 있는 타입(nullable type)을 지원
- 컴파일 시점에 널 포인터 예외 검사 가능

## 3. 함수형 프로그래밍과 객체지향 프로그래밍

![image](https://github.com/user-attachments/assets/0289e50e-fd99-4a0a-8941-f5d37f986934)

- 함수형 프로그래밍 개념
    - first-class 함수
        - 함수를 일반 값처럼 다룰 수 있음
        - 함수를 변수에 저장할 수 있음
        - 함수를 인자로 다른 함수에 전달할 수 있음
        - 함수에서 새로운 함수를 만들어서 반환할 수 있음
        
        ```kotlin
        fun f1(a: Int, b: Int): (Int, Int) -> Int {
            val f2 = fun(a: Int, b: Int): Int {
                return if (a > b) a else b
            }
            return f2
        }
        ```
        
    - 불변성
        - 불변 객체를 사용하여 프로그램 작성
    - 부수 효과(side-effect) 없음
        - 입력이 같으면 항상 같은 출력을 내놓음
        - 다른 객체의 상태를 변경하지 않음
        - 함수 외부나 다른 바깥 환경과 상호작용하지 않음
- 함수형 프로그래밍 장점
    - 간결성
        - 함수형 코드는 명령형 코드에 비해 더 간결함
        - (순수) 함수를 값처럼 활용할 수 있음
        
        ```kotlin
         
        // 람다식을 함수 인자로 전달 
        fun findAlice = findPerson {it.name == "Alice"}
        fun findBob = findPerson {it.name == "Bob"}
        ```
        
    - 다중 스레드
        - 다중 스레드 환경에서 같은 데이터를 여러 스레드가 변경할 수 없음
        - 불변 데이터 구조를 사용하고 함수를 그 데이터 구조에 적용
    - 테스트 용이
- 함수형 프로그래밍 지원 사항
    - 함수 타입을 지원, 함수를 파라미터로 받거나 함수가 새로운 함수를 반환할 수 있음
    - 람다식을 지원, 코드 블록을 쉽게 정의하고 전달할 수 있음
    - 데이터 클래스는 불변적인 값 객체를 간편하게 만들 수 있는 구문을 제공
    - 객체와 컬렉션을 함수형 스타일로 다룰 수 있는 API 제공

## 4. 무료 오픈소스

- 코틀린 언어와 컴파일러, 라이브러리는 모두 오픈소스임

# 3. 코틀린 응용

## 1. 코틀린 서버 프로그래밍

- 자바 코드와 매끄럽게 상호운용할 수 있음
- 자바 클래스를 코틀린으로 확장 가능

## 2. 코틀린 안드로이드 프로그래밍

- 코틀린 타입 시스템은 null 값을 정확히 추적

# 4. 코틀린의 철학

## 1. 실용성

- 항상 도구의 활용을 염두하고 설계됨

## 2. 간결성

- 게더, 세터, 필드에 값을 대입하기 위한 로직 등을 묵시적으로 제공
- 기능이 다양한 표준 라이브러리를 제공
- 람다를 통해 코드 블록을 라이브러리 함수에 쉽게 전달

## 3. 안전성

- JVM에서 실행하므로 메모리 안정성 보장, 버퍼 오버플로 등 방지
- 컴파일 시점 검사를 통해 오류를 더 많이 방지
- 널이 될 수 없는 값을 추적하며, `NullPointerException`이 발생할 수 있는 코드를 금지
- 타입 검사와 캐스트가 한 연산자에 의해 이뤄짐

# 4. 상호운용성

- 자바와 코틀린 소스 파일을 자유롭게 내비게이션

## 1. 실용성

- 항상 도구의 활용을 염두하고 설계됨

## 2. 간결성

- 게더, 세터, 필드에 값을 대입하기 위한 로직 등을 묵시적으로 제공
- 기능이 다양한 표준 라이브러리를 제공
- 람다를 통해 코드 블록을 라이브러리 함수에 쉽게 전달

## 3. 안전성

- JVM에서 실행하므로 메모리 안정성 보장, 버퍼 오버플로 등 방지
- 컴파일 시점 검사를 통해 오류를 더 많이 방지
- 널이 될 수 없는 값을 추적하며, `NullPointerException`이 발생할 수 있는 코드를 금지
- 타입 검사와 캐스트가 한 연산자에 의해 이뤄짐

## 4. 상호운용성

- 자바와 코틀린 소스 파일을 자유롭게 내비게이션

# 5. 코틀린 도구 사용

## 1. 코틀린 코드 컴파일

- 코틀린 런타임 라이브러리
    - 코틀린 자체 표준 라이브러리 클래스, 코틀린에서 자바 API 기능을 확장한 내용 포함
![image 1](https://github.com/user-attachments/assets/8fa86292-6c29-4ef3-886e-e80fa9355e09)

# 6. 요약

- 타입 추론을 지원하는 정적 타입 지정 언어로 정확성과 성능을 보장하면서 소스코드를 간결하게 유지
- 객체지향, 함수형 프로그래밍 스타일 모두 지원하며, 수준 높은 추상화가 가능하고 불변 값 지원
- 자바 프레임워크를 완벽하게 지원 및 HTML 생성기나 영속화 등의 작업을 위한 새로운 도구 지원
- 코틀린 런타임 라이브러리 크기는 작고, 코틀린 컴파일러는 안드로이드 API를 지원
